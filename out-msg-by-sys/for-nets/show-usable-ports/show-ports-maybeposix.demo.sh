# def
see_usable_ports () { seq $@ | sh -c 'awk '"`lsof -i -nOP 2>/dev/null | awk \{print\$9\} | tr -d \- | tr \> \\n | cut -d: -f2 | awk /[0-9]/ | sort -nu | awk \{print\"\\\\\\\\\\\\\<\"\$0\"\\\\\\\\\\\\\>\\\\\|\"\}END\{print\"\\\\\\\\\\\\\<x\\\\\\\\\\\\\>\/\"\}BEGIN\{ORS=\"\"\;print\"\\\\\!\/\"\}`" ; }
see_usable_ports () { sh -c 'seq '"$*"' | awk '"`lsof -i -nOP 2>/dev/null | awk \{print\$9\} | tr -d \- | tr \> \\n | cut -d: -f2 | awk /[0-9]/ | sort -nu | awk \{print\"\\\\\\\\\\\\\<\"\$0\"\\\\\\\\\\\\\>\\\\\|\"\}END\{print\"\\\\\\\\\\\\\<x\\\\\\\\\\\\\>\/\"\}BEGIN\{ORS=\"\"\;print\"\\\\\!\/\"\}`" ; }

# usage
see_usable_ports 40000 40220

## 其实目标不在于 POSIX 而是基于以下经验：
## 1. 如果一条命令一个单引号字符都没出现，那么便很容易夹在单引号之间用在各种需要这样用的地方。
## 2. 如果用了单引号所幸没用转义符，那还好，无非就是被多层单引号夹着会很难。
## 3. 如果转义和单引号都给用上了乃至于用上了 $'\xx' 这种玩意，那么这里想要做的事情可能就不太容易了：当然可以写成 '...''$'"'"\\'xx'"'"'...' 但这样一来就太费脑力了，而如果多重转义的话，这种麻烦我觉得还是把它一劳永逸掉比较好，写上面的那堆 \\\\\\... 的时候我快疯了，但上面那样做的价值就在于我只需要疯一次。
## 至于是不是 POSIX 我其实不在意的 ... 本来就是想搞个看空余 port 的 shell 实现罢了。何况真考虑老机器的话 awk 还有版本问题呢我也没在老机器测试过。只能说是尽量做到兼容性罢了。还有，文件名只是想不到更好的了，我当然也知道 POSIX 不是这么个含义的。。。。
